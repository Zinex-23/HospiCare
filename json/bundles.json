{
  "widgetsBundle": {
    "alias": "di_n",
    "title": "Diễn",
    "image": "",
    "scada": true,
    "description": "",
    "order": null,
    "name": "Diễn"
  },
  "widgetTypes": [
    {
      "fqn": "roi_",
      "name": "ROI ",
      "deprecated": false,
      "image": null,
      "description": null,
      "descriptor": {
        "type": "latest",
        "sizeX": 7.5,
        "sizeY": 3,
        "resources": [],
        "templateHtml": "<div class=\"wrapper\">\n    <div class=\"toolbar\">\n        <div class=\"toolbar-row\">\n            <div class=\"toolbar-left\">\n                <button class=\"tb-btn btn-save\" mat-button color=\"primary\" (click)=\"savePolygon()\">Save</button>\n                <button class=\"tb-btn btn-undo\" mat-button (click)=\"undoPoint()\">Undo</button>\n                <button class=\"tb-btn btn-clear\" mat-button (click)=\"clearAll()\">Clear</button>\n                <button class=\"tb-btn btn-reload\" mat-button (click)=\"reloadSaved()\">Reload</button>\n            </div>\n\n            <div class=\"toolbar-right\">\n                <div class=\"cam-box\">\n                    <label class=\"cam-label\">Camera</label>\n                    <select class=\"cam-dd\"></select>\n                </div>\n\n                <div class=\"roi-switch\">\n                    <button class=\"roi-btn active\" data-roi=\"Detect\">Detect</button>\n                    <button class=\"roi-btn\" data-roi=\"Region1\">Region1</button>\n                    <button class=\"roi-btn\" data-roi=\"Region2\">Region2</button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <div class=\"stage\">\n        <canvas></canvas>\n\n        <!-- Loading overlay -->\n        <div class=\"loading-overlay\">\n            <div class=\"loading-card\">\n                <div class=\"spinner\"></div>\n                <div class=\"loading-text\">Loading latest frame...</div>\n            </div>\n        </div>\n\n        <div class=\"toast-center\"></div>\n    </div>\n\n</div>\n",
        "templateCss": ".wrapper {\r\n    height: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    background: #fafafa;\r\n    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;\r\n}\r\n\r\n/* ===== Toolbar layout ===== */\r\n.toolbar {\r\n    background: #fff;\r\n    padding: 12px 16px;\r\n}\r\n\r\n.toolbar-row {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n    gap: 12px;\r\n    flex-wrap: nowrap;\r\n    position: relative;\r\n}\r\n\r\n.toolbar-left {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 8px;\r\n    flex-wrap: nowrap;\r\n    flex-shrink: 0;\r\n}\r\n\r\n.toolbar-right {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: flex-end;\r\n    gap: 16px;\r\n    flex-wrap: nowrap;\r\n    flex-shrink: 0;\r\n}\r\n\r\n/* ===== Toolbar Buttons ===== */\r\n.tb-btn {\r\n    height: 36px;\r\n    padding: 0 18px;\r\n    border: none;\r\n    border-radius: 8px;\r\n    font-size: 13.5px;\r\n    font-weight: 500;\r\n    cursor: pointer;\r\n    transition: all .2s cubic-bezier(.4, 0, .2, 1);\r\n    outline: none;\r\n    letter-spacing: 0.3px;\r\n}\r\n\r\n.btn-save {\r\n    background: #F44336;\r\n    color: #fff;\r\n    box-shadow: 0 2px 4px rgba(244, 67, 54, .2);\r\n}\r\n\r\n.btn-save:hover {\r\n    background: #E53935;\r\n    box-shadow: 0 4px 8px rgba(244, 67, 54, .3);\r\n    transform: translateY(-1px);\r\n}\r\n\r\n.btn-save:active {\r\n    transform: translateY(0);\r\n}\r\n\r\n.btn-undo,\r\n.btn-clear,\r\n.btn-reload {\r\n    background: #fff;\r\n    color: #424242;\r\n    border: 1px solid #e0e0e0;\r\n}\r\n\r\n.btn-undo:hover,\r\n.btn-clear:hover,\r\n.btn-reload:hover {\r\n    background: #fafafa;\r\n    border-color: #F44336;\r\n    color: #F44336;\r\n    transform: translateY(-1px);\r\n    box-shadow: 0 2px 6px rgba(244, 67, 54, .12);\r\n}\r\n\r\n.btn-undo:active,\r\n.btn-clear:active,\r\n.btn-reload:active {\r\n    transform: translateY(0);\r\n}\r\n\r\n/* ===== Camera Dropdown - Refined ===== */\r\n.cam-box {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 12px;\r\n    padding: 0;\r\n    border: none;\r\n    background: transparent;\r\n}\r\n\r\n.cam-label {\r\n    font-size: 14px;\r\n    color: #334155;\r\n    /* Slate 700 */\r\n    font-weight: 600;\r\n    white-space: nowrap;\r\n}\r\n\r\n.cam-dd {\r\n    height: 36px;\r\n    padding: 0 36px 0 12px;\r\n    background: #fff url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2364748b'><path d='M7 10l5 5 5-5z'/></svg>\") no-repeat right 8px center;\r\n    background-size: 20px;\r\n    border: 1px solid #e2e8f0;\r\n    border-radius: 8px;\r\n    font-size: 13px;\r\n    font-weight: 600;\r\n    color: #475569;\r\n    cursor: pointer;\r\n    outline: none;\r\n    appearance: none;\r\n    -webkit-appearance: none;\r\n    min-width: 140px;\r\n    transition: all 0.2s ease;\r\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);\r\n}\r\n\r\n.cam-dd:hover {\r\n    border-color: #cbd5e1;\r\n    background-color: #f8fafc;\r\n    color: #1e293b;\r\n}\r\n\r\n.cam-dd:focus {\r\n    border-color: #3b82f6;\r\n    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\r\n}\r\n\r\n/* ===== ROI Switch - Segmented Control Style ===== */\r\n.roi-switch {\r\n    display: flex;\r\n    gap: 0;\r\n    /* Connected items */\r\n    padding: 4px;\r\n    background: #f1f5f9;\r\n    /* Slate 100 */\r\n    border: 1px solid #e2e8f0;\r\n    border-radius: 10px;\r\n    align-items: center;\r\n}\r\n\r\n.roi-btn {\r\n    height: 32px;\r\n    padding: 0 16px;\r\n    border: none;\r\n    background: transparent;\r\n    border-radius: 7px;\r\n    cursor: pointer;\r\n    font-size: 13px;\r\n    font-weight: 600;\r\n    color: #64748b;\r\n    /* Slate 500 */\r\n    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);\r\n    position: relative;\r\n    user-select: none;\r\n}\r\n\r\n.roi-btn:hover:not(.active) {\r\n    color: #1e293b;\r\n    background: rgba(255, 255, 255, 0.5);\r\n}\r\n\r\n/* Active State Common */\r\n.roi-btn.active {\r\n    background: #fff;\r\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);\r\n}\r\n\r\n/* Detect - Yellow/Orange Text */\r\n.roi-btn[data-roi=\"Detect\"].active {\r\n    color: #d97706;\r\n    /* Amber 600 */\r\n}\r\n\r\n/* Region1 - Green Text */\r\n.roi-btn[data-roi=\"Region1\"].active {\r\n    color: #16a34a;\r\n    /* Green 600 */\r\n}\r\n\r\n/* Region2 - Red Text */\r\n.roi-btn[data-roi=\"Region2\"].active {\r\n    color: #dc2626;\r\n    /* Red 600 */\r\n}\r\n\r\n/* ===== Stage ===== */\r\n.stage {\r\n    flex: 1;\r\n    position: relative;\r\n    min-height: 0;\r\n    background: #fff;\r\n}\r\n\r\n.stage canvas {\r\n    position: absolute;\r\n    inset: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    display: block;\r\n    cursor: crosshair;\r\n    background: #fff;\r\n    transition: cursor 0.2s ease;\r\n}\r\n\r\n.stage canvas.can-click-edge {\r\n    cursor: pointer;\r\n}\r\n\r\n.roi-hint {\r\n    font-size: 14.5px;\r\n    color: #64748b;\r\n    padding: 0 6px;\r\n    white-space: nowrap;\r\n    display: inline-flex;\r\n    align-items: center;\r\n    gap: 8px;\r\n    position: absolute;\r\n    left: 50%;\r\n    transform: translateX(-50%);\r\n    font-weight: 600;\r\n}\r\n\r\n.roi-hint.is-edge {\r\n    font-size: 16px;\r\n    font-weight: 700;\r\n    color: #334155;\r\n}\r\n\r\n.roi-hint .hint-square {\r\n    width: 12px;\r\n    height: 12px;\r\n    border-radius: 3px;\r\n    display: inline-block;\r\n    vertical-align: middle;\r\n    margin: 0 4px;\r\n}\r\n\r\n.roi-hint .square-green {\r\n    background: #22c55e;\r\n}\r\n\r\n.roi-hint .square-red {\r\n    background: #ef4444;\r\n}\r\n\r\n.roi-hint .hint-arrow {\r\n    font-weight: 700;\r\n    margin: 0 4px;\r\n    line-height: 1;\r\n    display: inline-block;\r\n}\r\n\r\n.roi-hint.is-edge .hint-arrow {\r\n    font-size: 20px;\r\n    transform: scaleX(1.6);\r\n}\r\n\r\n/* ===== Loading overlay - mượt hơn ===== */\r\n.loading-overlay {\r\n    position: absolute;\r\n    inset: 0;\r\n    display: none;\r\n    align-items: center;\r\n    justify-content: center;\r\n    background: rgba(250, 250, 250, .85);\r\n    backdrop-filter: blur(4px);\r\n    z-index: 25;\r\n    pointer-events: none;\r\n    opacity: 0;\r\n    transition: opacity .3s ease;\r\n}\r\n\r\n.stage.is-loading .loading-overlay {\r\n    display: flex;\r\n    animation: fadeInOverlay .3s ease forwards;\r\n}\r\n\r\n@keyframes fadeInOverlay {\r\n    from {\r\n        opacity: 0;\r\n    }\r\n\r\n    to {\r\n        opacity: 1;\r\n    }\r\n}\r\n\r\n.loading-card {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 14px;\r\n    padding: 16px 22px;\r\n    border-radius: 12px;\r\n    background: #fff;\r\n    box-shadow: 0 8px 32px rgba(0, 0, 0, .12);\r\n    color: #212121;\r\n    font-size: 14px;\r\n    font-weight: 500;\r\n    transform: scale(.96);\r\n    animation: loadingCardIn .4s cubic-bezier(.34, 1.56, .64, 1) forwards;\r\n}\r\n\r\n@keyframes loadingCardIn {\r\n    from {\r\n        opacity: 0;\r\n        transform: scale(.92) translateY(8px);\r\n    }\r\n\r\n    to {\r\n        opacity: 1;\r\n        transform: scale(1) translateY(0);\r\n    }\r\n}\r\n\r\n.spinner {\r\n    width: 20px;\r\n    height: 20px;\r\n    border-radius: 999px;\r\n    border: 2.5px solid rgba(244, 67, 54, .2);\r\n    border-top-color: #F44336;\r\n    animation: spin .7s cubic-bezier(.8, .2, .2, .8) infinite;\r\n}\r\n\r\n@keyframes spin {\r\n    from {\r\n        transform: rotate(0deg)\r\n    }\r\n\r\n    to {\r\n        transform: rotate(360deg)\r\n    }\r\n}\r\n\r\n/* ===== Button animation - mượt hơn ===== */\r\n.tb-btn {\r\n    transition: all .25s cubic-bezier(.4, 0, .2, 1);\r\n    position: relative;\r\n}\r\n\r\n.tb-btn.is-working {\r\n    animation: tbPulse .8s cubic-bezier(.4, 0, .6, 1) infinite;\r\n    pointer-events: none;\r\n}\r\n\r\n.tb-btn.is-success {\r\n    animation: tbSuccess .5s cubic-bezier(.34, 1.56, .64, 1);\r\n}\r\n\r\n.tb-btn.is-error {\r\n    animation: tbError .5s cubic-bezier(.36, .07, .19, .97);\r\n}\r\n\r\n@keyframes tbPulse {\r\n\r\n    0%,\r\n    100% {\r\n        transform: scale(1)\r\n    }\r\n\r\n    50% {\r\n        transform: scale(1.04)\r\n    }\r\n}\r\n\r\n@keyframes tbSuccess {\r\n    0% {\r\n        transform: scale(1)\r\n    }\r\n\r\n    30% {\r\n        transform: scale(1.08) rotate(2deg)\r\n    }\r\n\r\n    60% {\r\n        transform: scale(.96) rotate(-1deg)\r\n    }\r\n\r\n    100% {\r\n        transform: scale(1) rotate(0)\r\n    }\r\n}\r\n\r\n@keyframes tbError {\r\n\r\n    0%,\r\n    100% {\r\n        transform: translateX(0)\r\n    }\r\n\r\n    20% {\r\n        transform: translateX(-4px) rotate(-2deg)\r\n    }\r\n\r\n    40% {\r\n        transform: translateX(4px) rotate(2deg)\r\n    }\r\n\r\n    60% {\r\n        transform: translateX(-3px) rotate(-1deg)\r\n    }\r\n\r\n    80% {\r\n        transform: translateX(2px) rotate(1deg)\r\n    }\r\n}\r\n\r\n/* ===== Toast - animation mượt mà hơn ===== */\r\n.toast-center {\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 20%;\r\n    transform: translateX(-50%);\r\n    z-index: 30;\r\n    pointer-events: none;\r\n}\r\n\r\n.toast {\r\n    min-width: 400px;\r\n    max-width: 640px;\r\n    padding: 16px 24px;\r\n    border-radius: 12px;\r\n    color: #fff;\r\n    font-size: 14px;\r\n    font-weight: 500;\r\n    line-height: 1.4;\r\n    text-align: center;\r\n    box-shadow: 0 12px 40px rgba(0, 0, 0, .15);\r\n    opacity: 0;\r\n    transform: translateY(20px) scale(.94);\r\n    animation:\r\n        toastSlideIn .4s cubic-bezier(.34, 1.56, .64, 1) forwards,\r\n        toastSlideOut .4s cubic-bezier(.4, 0, .68, .06) 2.2s forwards;\r\n    position: relative;\r\n    left: 50%;\r\n    margin-left: -50%;\r\n}\r\n\r\n.toast.success {\r\n    background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%);\r\n}\r\n\r\n.toast.error {\r\n    background: linear-gradient(135deg, #F44336 0%, #EF5350 100%);\r\n}\r\n\r\n.toast.info {\r\n    background: linear-gradient(135deg, #2196F3 0%, #42A5F5 100%);\r\n}\r\n\r\n.toast.warn {\r\n    background: linear-gradient(135deg, #FF9800 0%, #FFA726 100%);\r\n}\r\n\r\n@keyframes toastSlideIn {\r\n    0% {\r\n        opacity: 0;\r\n        transform: translateY(24px) scale(.94);\r\n    }\r\n\r\n    60% {\r\n        opacity: 1;\r\n        transform: translateY(-4px) scale(1.02);\r\n    }\r\n\r\n    100% {\r\n        opacity: 1;\r\n        transform: translateY(0) scale(1);\r\n    }\r\n}\r\n\r\n@keyframes toastSlideOut {\r\n    0% {\r\n        opacity: 1;\r\n        transform: translateY(0) scale(1);\r\n    }\r\n\r\n    100% {\r\n        opacity: 0;\r\n        transform: translateY(-30px) scale(.96);\r\n    }\r\n}\r\n\r\n/* ===== Responsive ===== */\r\n@media (max-width: 768px) {\r\n    .toolbar {\r\n        padding: 10px 12px;\r\n    }\r\n\r\n    .toolbar-row {\r\n        gap: 8px;\r\n    }\r\n\r\n    .toolbar-left,\r\n    .toolbar-right {\r\n        gap: 6px;\r\n    }\r\n\r\n    .tb-btn {\r\n        height: 34px;\r\n        padding: 0 14px;\r\n        font-size: 12.5px;\r\n    }\r\n\r\n    .cam-dd {\r\n        min-width: 120px;\r\n        height: 34px;\r\n    }\r\n\r\n    .toast {\r\n        min-width: 300px;\r\n        font-size: 13px;\r\n    }\r\n}",
        "controllerScript": "self.onInit = function () {\n    const $injector = self.ctx.$scope.$injector;\n    const attributeService = $injector.get(self.ctx.servicesMap.get('attributeService'));\n\n    // AngularJS i18n services (robust)\n    let $translate = null;\n    let $rootScope = null;\n    try { $translate = $injector.get('$translate'); } catch (e) { }\n    try { $rootScope = $injector.get('$rootScope'); } catch (e) { }\n\n    const ds = self.ctx.datasources?.[0];\n    self._entityId = ds?.entity?.id;\n    if (!self._entityId) {\n        console.error('No datasource entity. Please select Entity alias.');\n        return;\n    }\n\n    const $c = self.ctx.$container;\n    const stageEl = $c.find('.stage')[0];\n    const canvasEl = $c.find('canvas')[0];\n    const camBoxEl = $c.find('.cam-box')[0];\n    const selectEl = $c.find('.cam-dd')[0];\n    const roiSwitchEl = $c.find('.roi-switch')[0];\n    const roiBtns = Array.from($c.find('.roi-btn'));\n    const toastCenter = $c.find('.toast-center')[0];\n    const roiHintEl = $c.find('.roi-hint')[0];\n\n    const btnSaveEl = $c.find('.btn-save')[0];\n    const btnUndoEl = $c.find('.btn-undo')[0];\n    const btnClearEl = $c.find('.btn-clear')[0];\n    const btnReloadEl = $c.find('.btn-reload')[0];\n\n    const loadingTextEl = $c.find('.loading-text')[0];\n    const camLabelEl = $c.find('.cam-label')[0];\n\n    const g = canvasEl.getContext('2d');\n\n    self._mode = 'tablet'; // single device mode\n\n    self._cams = [];\n    self._activeCam = null; // only for edge\n\n    // ✅ NEW: ưu tiên cam hiển thị ban đầu (đọc từ SERVER_SCOPE.current_cam)\n    self._preferredCamId = null;\n\n    self._bgImg = new Image();\n    self._bgReady = false;\n    self._lastSrc = null;\n\n    self._imgDraw = { offX: 0, offY: 0, drawW: 0, drawH: 0 };\n\n    self._tabletPair = []; // [{x,y}] or [{x,y},{x,y}]\n    self._lineTypes = [null, null, null, null];\n    self._justAddedPoint = false;\n    self._roisNorm = { Detect: [], Region1: [], Region2: [] };\n    self._activeRoiName = 'Detect';\n    self._pending = null;\n\n    // i18n state\n    self._lang = 'en';\n    self._camPrefixText = 'Cam';\n    self._unsubTranslate = null;\n\n    const ROI_COLOR = { Detect: '#FFD400', Region1: '#22C55E', Region2: '#EF4444' };\n\n    /* =========================\n     * i18n (EN/JA switchable)\n     * ========================= */\n    const I18N = {\n        en: {\n            save: 'Save',\n            undo: 'Undo',\n            clear: 'Clear',\n            reload: 'Reload',\n            camera: 'Camera',\n            detect: 'Detect',\n            region1: 'Region1',\n            region2: 'Region2',\n            loading: 'Loading latest frame...',\n            noCamera: 'No camera',\n            camPrefix: 'Cam',\n            toast_success: 'Succeeded.',\n            toast_failed: 'Failed.',\n            err_no_cam_selected: 'No camera selected.',\n            err_frame_loading_try_again: 'Frame is loading. Please try again.',\n            err_need_3_rois: 'You must draw 3 ROIs (Detect, Region1, Region2), each with at least 3 points.',\n            err_need_2_points: 'Please select 2 points to create a line.',\n            err_failed_request_frame: 'Failed to request frame.',\n            err_failed_load_image: 'Failed to load frame image.',\n            err_need_4_points: 'Please draw at least 3 points to create ROI.',\n            err_need_in_out: '',\n            err_invalid_stat_cfg: 'Invalid statistic_config format.',\n            hint_tablet: 'Tap to draw ROI points, then Save.',\n            hint_edge_entry: 'Pass : '\n        },\n        ja: {\n            save: '保存',\n            undo: '元に戻す',\n            clear: 'クリア',\n            reload: '再読み込み',\n            camera: 'カメラ',\n            detect: '検出',\n            region1: '領域1',\n            region2: '領域2',\n            loading: '最新フレームを読み込み中...',\n            noCamera: 'カメラなし',\n            camPrefix: 'カメラ',\n            toast_success: '成功しました。',\n            toast_failed: '失敗しました。',\n            err_no_cam_selected: 'カメラが選択されていません。',\n            err_frame_loading_try_again: 'フレームを読み込み中です。もう一度お試しください。',\n            err_need_3_rois: '3つのROI（検出・領域1・領域2）をそれぞれ3点以上で描画してください。',\n            err_need_2_points: '線を作成するには2点を選択してください。',\n            err_failed_request_frame: 'フレーム要求に失敗しました。',\n            err_failed_load_image: 'フレーム画像の読み込みに失敗しました。',\n            err_need_4_points: 'ROIを作成するには3点以上を選択してください。',\n            err_need_in_out: '',\n            err_invalid_stat_cfg: 'statistic_configの形式が不正です。',\n            hint_tablet: 'タップしてROI点を描画し、保存してください。',\n            hint_edge_entry: '通過 : '\n        }\n    };\n\n    function normLang(l) {\n        if (!l) return 'en';\n        l = String(l).toLowerCase();\n        if (l.indexOf('ja') === 0) return 'ja';\n        return 'en';\n    }\n\n    function t(key) {\n        const d = I18N[self._lang] || I18N.en;\n        if (d && d[key] != null) return d[key];\n        return '';\n    }\n\n    function detectLang() {\n        try {\n            if ($translate && typeof $translate.use === 'function') {\n                const used = $translate.use();\n                if (used) return normLang(used);\n            }\n        } catch (e) { }\n\n        try {\n            const ls = localStorage.getItem('tb.lang') ||\n                localStorage.getItem('tbLang') ||\n                localStorage.getItem('language') ||\n                localStorage.getItem('lang');\n            if (ls) return normLang(ls);\n        } catch (e) { }\n\n        try {\n            const hl = document && document.documentElement ? document.documentElement.lang : '';\n            if (hl) return normLang(hl);\n        } catch (e) { }\n\n        try { return normLang(navigator.language); } catch (e) { }\n        return 'en';\n    }\n\n    function applyI18nToUI() {\n        if (btnSaveEl) btnSaveEl.textContent = t('save');\n        if (btnUndoEl) btnUndoEl.textContent = t('undo');\n        if (btnClearEl) btnClearEl.textContent = t('clear');\n        if (btnReloadEl) btnReloadEl.textContent = t('reload');\n\n        if (camLabelEl) camLabelEl.textContent = t('camera');\n        if (loadingTextEl) loadingTextEl.textContent = t('loading');\n        updateHint();\n\n        for (let i = 0; i < roiBtns.length; i++) {\n            const b = roiBtns[i];\n            if (!b) continue;\n            const roiName = b.dataset ? b.dataset.roi : null;\n            if (roiName === 'Detect') b.textContent = t('detect');\n            else if (roiName === 'Region1') b.textContent = t('region1');\n            else if (roiName === 'Region2') b.textContent = t('region2');\n        }\n\n        self._camPrefixText = t('camPrefix') || 'Cam';\n\n        // update existing dropdown options text\n        try {\n            const opts = selectEl ? selectEl.options : null;\n            if (opts) {\n                for (let j = 0; j < opts.length; j++) {\n                    const opt = opts[j];\n                    if (!opt) continue;\n                    if (opt.value === '') opt.textContent = t('noCamera');\n                    else opt.textContent = self._camPrefixText + ' ' + opt.value;\n                }\n            }\n        } catch (e) { }\n    }\n\n    function setLang(nextLang) {\n        const n = normLang(nextLang);\n        if (n === self._lang) return;\n        self._lang = n;\n        applyI18nToUI();\n    }\n\n    function updateHint() {\n        if (!roiHintEl) return;\n        roiHintEl.classList.remove('is-edge');\n        roiHintEl.textContent = t('hint_tablet');\n        roiHintEl.style.display = '';\n    }\n\n    function initI18n() {\n        self._lang = detectLang();\n        applyI18nToUI();\n\n        try { if (typeof self._unsubTranslate === 'function') self._unsubTranslate(); } catch (e) { }\n        self._unsubTranslate = null;\n\n        if ($rootScope && typeof $rootScope.$on === 'function') {\n            self._unsubTranslate = $rootScope.$on('$translateChangeSuccess', function () {\n                let used2 = null;\n                try { used2 = ($translate && typeof $translate.use === 'function') ? $translate.use() : null; } catch (e) { }\n                setLang(used2 || detectLang());\n            });\n        }\n    }\n\n    /* ===== Toast ===== */\n    function toast(type, msg) {\n        if (!toastCenter) return;\n        const el = document.createElement('div');\n        el.className = `toast ${type || 'info'}`;\n        el.textContent = msg;\n        toastCenter.appendChild(el);\n        setTimeout(() => { try { toastCenter.removeChild(el); } catch (e) { } }, 2700);\n    }\n\n    /* ===== Loading ===== */\n    function setLoading(on) {\n        if (!stageEl) return;\n        stageEl.classList.toggle('is-loading', !!on);\n    }\n    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }\n\n    function getStageWH() { return { w: stageEl.clientWidth, h: stageEl.clientHeight }; }\n\n    function blankWhite() {\n        const { w: stageW, h: stageH } = getStageWH();\n        g.save();\n        g.clearRect(0, 0, stageW, stageH);\n        g.fillStyle = '#fff';\n        g.fillRect(0, 0, stageW, stageH);\n        g.restore();\n    }\n\n    /* ===== Button feedback (Undo silent) ===== */\n    function setBtnState(btn, state) {\n        if (!btn) return;\n        btn.classList.remove('is-working', 'is-success', 'is-error');\n        if (state) {\n            btn.classList.add(state);\n            if (state === 'is-success' || state === 'is-error') {\n                setTimeout(() => btn.classList.remove(state), 900);\n            }\n        }\n    }\n\n    function runWithFeedback(btn, actionName, fn, opts) {\n        const silent = !!(opts && opts.silent);\n        try {\n            setBtnState(btn, 'is-working');\n            const res = fn();\n            if (res && typeof res.then === 'function') {\n                return res.then(() => {\n                    setBtnState(btn, null);\n                    setBtnState(btn, 'is-success');\n                    if (!silent) toast('success', t('toast_success'));\n                }).catch((e) => {\n                    setBtnState(btn, null);\n                    setBtnState(btn, 'is-error');\n                    if (!silent) toast('error', e?.message ? e.message : t('toast_failed'));\n                });\n            } else {\n                setBtnState(btn, null);\n                setBtnState(btn, 'is-success');\n                if (!silent) toast('success', t('toast_success'));\n            }\n        } catch (e) {\n            setBtnState(btn, null);\n            setBtnState(btn, 'is-error');\n            if (!silent) toast('error', e?.message ? e.message : t('toast_failed'));\n        }\n    }\n\n    /* ===== Utils ===== */\n    function clamp01(n) { return Math.max(0, Math.min(1, n)); }\n\n    function computeImageDrawRect(stageW, stageH) {\n        if (!self._bgReady) return self._imgDraw = { offX: 0, offY: 0, drawW: 0, drawH: 0 };\n        const imgW = self._bgImg.naturalWidth || 1;\n        const imgH = self._bgImg.naturalHeight || 1;\n        const scale = Math.min(stageW / imgW, stageH / imgH);\n        const drawW = imgW * scale;\n        const drawH = imgH * scale;\n        const offX = (stageW - drawW) / 2;\n        const offY = (stageH - drawH) / 2;\n        return self._imgDraw = { offX, offY, drawW, drawH };\n    }\n\n    function evToPointOnImageNorm(ev) {\n        const { w: stageW, h: stageH } = getStageWH();\n        const r = canvasEl.getBoundingClientRect();\n        const xCss = ev.clientX - r.left;\n        const yCss = ev.clientY - r.top;\n        const { offX, offY, drawW, drawH } = computeImageDrawRect(stageW, stageH);\n        if (drawW <= 0 || drawH <= 0) return null;\n        if (xCss < offX || xCss > offX + drawW || yCss < offY || yCss > offY + drawH) return null;\n        return { x: clamp01((xCss - offX) / drawW), y: clamp01((yCss - offY) / drawH) };\n    }\n\n    function normToCanvasPt(p) {\n        const r = self._imgDraw;\n        return { x: r.offX + p.x * r.drawW, y: r.offY + p.y * r.drawH };\n    }\n\n    function normToPixelFlat(pointsNorm) {\n        const imgW = self._bgImg.naturalWidth || 1;\n        const imgH = self._bgImg.naturalHeight || 1;\n        const flat = [];\n        for (const p of pointsNorm) flat.push(Math.round(p.x * imgW), Math.round(p.y * imgH));\n        return flat;\n    }\n\n    function pixelFlatToNorm(flat) {\n        const imgW = self._bgImg.naturalWidth || 1;\n        const imgH = self._bgImg.naturalHeight || 1;\n        const pts = [];\n        for (let i = 0; i + 1 < flat.length; i += 2) {\n            pts.push({ x: clamp01(Number(flat[i]) / imgW), y: clamp01(Number(flat[i + 1]) / imgH) });\n        }\n        return pts;\n    }\n\n    function polygonAreaNorm(pointsNorm) {\n        if (!pointsNorm || pointsNorm.length < 3) return 0;\n        let sum = 0;\n        for (let i = 0; i < pointsNorm.length; i++) {\n            const p1 = pointsNorm[i];\n            const p2 = pointsNorm[(i + 1) % pointsNorm.length];\n            sum += (p1.x * p2.y) - (p2.x * p1.y);\n        }\n        return Math.abs(sum) / 2;\n    }\n\n    function dist2PointToSegment(px, py, x1, y1, x2, y2) {\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        if (dx === 0 && dy === 0) {\n            const ox = px - x1;\n            const oy = py - y1;\n            return ox * ox + oy * oy;\n        }\n        const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);\n        const tt = Math.max(0, Math.min(1, t));\n        const cx = x1 + tt * dx;\n        const cy = y1 + tt * dy;\n        const ox = px - cx;\n        const oy = py - cy;\n        return ox * ox + oy * oy;\n    }\n\n    function getEdgeIndexAtPos(ev) {\n        if (!self._tabletPair || self._tabletPair.length !== 4) return null;\n        const r = canvasEl.getBoundingClientRect();\n        const mx = ev.clientX - r.left;\n        const my = ev.clientY - r.top;\n        const img = self._imgDraw;\n        if (mx < img.offX || mx > img.offX + img.drawW || my < img.offY || my > img.offY + img.drawH) return null;\n\n        const pts = self._tabletPair.map(normToCanvasPt);\n        let bestIdx = null;\n        let bestDist2 = Infinity;\n        const hit2 = 8 * 8;\n        for (let i = 0; i < 4; i++) {\n            const p1 = pts[i];\n            const p2 = pts[(i + 1) % 4];\n            const d2 = dist2PointToSegment(mx, my, p1.x, p1.y, p2.x, p2.y);\n            if (d2 < hit2 && d2 < bestDist2) {\n                bestDist2 = d2;\n                bestIdx = i;\n            }\n        }\n        return bestIdx;\n    }\n\n    function getLatestPointsFromCfg(cfg) {\n        if (!cfg || !Array.isArray(cfg.points) || !cfg.points.length) return [];\n        const isZeroFlat = (flat) => Array.isArray(flat) && flat.length >= 6 && flat.every(v => Number(v) === 0);\n        const isValidFlat = (flat) => Array.isArray(flat) && flat.length >= 6 && flat.length % 2 === 0 && !isZeroFlat(flat);\n\n        if (typeof cfg.points[0] === 'number') {\n            return isValidFlat(cfg.points) ? cfg.points : [];\n        }\n        if (Array.isArray(cfg.points[0])) {\n            for (let i = cfg.points.length - 1; i >= 0; i--) {\n                const candidate = cfg.points[i];\n                if (isValidFlat(candidate)) return candidate;\n            }\n            return [];\n        }\n        return [];\n    }\n\n    /* ===== Mode UI ===== */\n    function applyModeUI() {\n        if (camBoxEl) camBoxEl.style.display = 'none';\n        if (roiSwitchEl) roiSwitchEl.style.display = 'none';\n        updateHint();\n        updateCursor();\n    }\n\n    /* ===== Cursor Management ===== */\n    function updateCursor() {\n        if (canvasEl) canvasEl.classList.remove('can-click-edge');\n    }\n\n    function setActiveRoi(name) {\n        self._activeRoiName = name;\n        roiBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.roi === name));\n        redraw();\n    }\n\n    roiBtns.forEach(btn => {\n        btn.addEventListener('click', () => {\n            if (self._mode !== 'edge') return;\n            setActiveRoi(btn.dataset.roi);\n        });\n    });\n\n    /* ===== Render ===== */\n    function redraw() {\n        const { w: stageW, h: stageH } = getStageWH();\n        g.clearRect(0, 0, stageW, stageH);\n        if (!self._bgReady) return;\n\n        const rect = computeImageDrawRect(stageW, stageH);\n        g.drawImage(self._bgImg, rect.offX, rect.offY, rect.drawW, rect.drawH);\n\n        drawTabletPolygon(self._tabletPair);\n\n        // Update cursor based on state\n        updateCursor();\n    }\n\n    function drawTabletPolygon(points) {\n        if (!points || !points.length) return;\n        const r = self._imgDraw;\n        const baseColor = '#F44336';\n\n        g.save();\n        g.strokeStyle = baseColor;\n        g.fillStyle = baseColor;\n        g.lineWidth = 2.6;\n\n        // Draw closed loop with fill\n        if (points.length >= 3) {\n            g.save();\n            g.globalAlpha = 0.2; // Fill opacity\n            g.beginPath();\n            g.moveTo(r.offX + points[0].x * r.drawW, r.offY + points[0].y * r.drawH);\n            for (let i = 1; i < points.length; i++) {\n                g.lineTo(r.offX + points[i].x * r.drawW, r.offY + points[i].y * r.drawH);\n            }\n            g.closePath();\n            g.fill();\n            g.restore();\n        }\n\n        // Draw polygon lines\n        if (points.length >= 2) {\n            const closeLoop = points.length >= 3;\n            const edgeCount = closeLoop ? points.length : points.length - 1;\n            for (let i = 0; i < edgeCount; i++) {\n                const p1 = points[i];\n                const p2 = points[(i + 1) % points.length];\n                g.globalAlpha = 0.92;\n                g.beginPath();\n                g.moveTo(r.offX + p1.x * r.drawW, r.offY + p1.y * r.drawH);\n                g.lineTo(r.offX + p2.x * r.drawW, r.offY + p2.y * r.drawH);\n                g.stroke();\n            }\n        }\n\n        // Draw points\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            const cx = r.offX + p.x * r.drawW;\n            const cy = r.offY + p.y * r.drawH;\n            g.beginPath();\n            g.arc(cx, cy, 4.5, 0, Math.PI * 2);\n            g.fill();\n        }\n\n        g.restore();\n    }\n\n    function drawRoi(pointsNorm, name, isActive) {\n        if (!pointsNorm || !pointsNorm.length) return;\n        const r = self._imgDraw;\n        const color = ROI_COLOR[name] || 'red';\n\n        g.save();\n        g.strokeStyle = color;\n        g.fillStyle = color;\n        g.lineWidth = isActive ? 2.8 : 1.6;\n        g.globalAlpha = isActive ? 1 : 0.55;\n\n        if (pointsNorm.length >= 3) {\n            g.save();\n            g.globalAlpha = isActive ? 0.18 : 0.10;\n            g.beginPath();\n            g.moveTo(r.offX + pointsNorm[0].x * r.drawW, r.offY + pointsNorm[0].y * r.drawH);\n            for (let i = 1; i < pointsNorm.length; i++) {\n                g.lineTo(r.offX + pointsNorm[i].x * r.drawW, r.offY + pointsNorm[i].y * r.drawH);\n            }\n            g.closePath();\n            g.fill();\n            g.restore();\n        }\n\n        if (pointsNorm.length >= 2) {\n            g.beginPath();\n            g.moveTo(r.offX + pointsNorm[0].x * r.drawW, r.offY + pointsNorm[0].y * r.drawH);\n            for (let i = 1; i < pointsNorm.length; i++) {\n                g.lineTo(r.offX + pointsNorm[i].x * r.drawW, r.offY + pointsNorm[i].y * r.drawH);\n            }\n            g.stroke();\n        }\n\n        for (let i = 0; i < pointsNorm.length; i++) {\n            const p = pointsNorm[i];\n            const cx = r.offX + p.x * r.drawW;\n            const cy = r.offY + p.y * r.drawH;\n            g.beginPath();\n            g.arc(cx, cy, 4, 0, Math.PI * 2);\n            g.fill();\n        }\n        g.restore();\n    }\n\n    /* ===== Resize (DPR) ===== */\n    const resize = () => {\n        const rect = stageEl.getBoundingClientRect();\n        const dpr = window.devicePixelRatio || 1;\n        canvasEl.width = Math.max(1, Math.floor(rect.width * dpr));\n        canvasEl.height = Math.max(1, Math.floor(rect.height * dpr));\n        g.setTransform(dpr, 0, 0, dpr, 0, 0);\n        redraw();\n    };\n    self._ro = new ResizeObserver(resize);\n    self._ro.observe(stageEl);\n    resize();\n\n    /* =========================\n     * ✅ NEW: read SERVER_SCOPE.current_cam\n     * ========================= */\n    function normalizeCamIdFromCurrentCam(v) {\n        if (v == null) return null;\n        const s = String(v).trim();\n        if (!s) return null;\n        // accept: \"7\", \"CAM_7\", \"CAM7\", \"CAM 7\"\n        const m = s.match(/(\\d+)/);\n        return m ? String(Number(m[1])) : null;\n    }\n\n    function loadCurrentCamServer() {\n        return new Promise((resolve) => {\n            attributeService.getEntityAttributes(self._entityId, 'SERVER_SCOPE', ['current_cam'])\n                .subscribe(\n                    (attrs) => {\n                        const a = (attrs || []).find(x => x.key === 'current_cam');\n                        self._preferredCamId = normalizeCamIdFromCurrentCam(a?.value);\n                        resolve(self._preferredCamId);\n                    },\n                    () => resolve(null)\n                );\n        });\n    }\n\n    /* ===== Telemetry pass_cam (edge only) ===== */\n    function readPassCamFromTelemetry() {\n        const dataArr = self.ctx.data || [];\n        const entry = dataArr.find(d => d?.dataKey?.name === 'pass_cam');\n        if (!entry || !entry.data || !entry.data.length) return null;\n        let v = entry.data[0][1];\n        if (v == null || v === '') return null;\n        if (typeof v === 'string') { try { v = JSON.parse(v); } catch { return null; } }\n        return v;\n    }\n\n    function updateCamsFromTelemetry() {\n        const obj = readPassCamFromTelemetry();\n        if (!obj || typeof obj !== 'object') {\n            self._cams = [];\n            if (selectEl) selectEl.innerHTML = `<option value=\"\">${t('noCamera')}</option>`;\n            return;\n        }\n        const camIds = Object.keys(obj).sort((a, b) => Number(a) - Number(b));\n        self._cams = camIds;\n\n        if (!selectEl) return;\n        selectEl.innerHTML = '';\n        camIds.forEach(id => {\n            const opt = document.createElement('option');\n            opt.value = id;\n            opt.textContent = `${self._camPrefixText} ${id}`;\n            selectEl.appendChild(opt);\n        });\n\n        // ✅ CHANGED: ưu tiên activeCam -> preferredCamId(current_cam) -> cam đầu\n        const next =\n            (self._activeCam && camIds.includes(self._activeCam)) ? self._activeCam :\n                (self._preferredCamId && camIds.includes(self._preferredCamId)) ? self._preferredCamId :\n                    camIds[0];\n\n        selectEl.value = next;\n        if (next && next !== self._activeCam) setActiveCam(next);\n    }\n\n    if (selectEl) {\n        selectEl.addEventListener('change', () => {\n            const camId = selectEl.value;\n            if (camId) setActiveCam(camId);\n        });\n    }\n\n    /* ===== Trigger get_frame_cam ===== */\n    // EDGE: value = camId string (ex: \"2\")\n    // TABLET/DEFAULT: value = timestamp (keep legacy behavior)\n    function triggerGetFrameCam(val) {\n        return new Promise((resolve, reject) => {\n            attributeService.saveEntityAttributes(self._entityId, 'SHARED_SCOPE', [\n                { key: 'get_frame_cam', value: String(val) }\n            ]).subscribe(() => resolve(), err => reject(err));\n        });\n    }\n\n    async function refreshLatestFrame() {\n        setLoading(true);\n        try {\n            const payload = Date.now();\n            await triggerGetFrameCam(payload);\n            await sleep(2000);\n            fetchFrame();\n        } catch (e) {\n            setLoading(false);\n            toast('error', e?.message || t('err_failed_request_frame'));\n        }\n    }\n\n    /* ===== Single device mode ===== */\n    function loadDeviceLabel() {\n        self._mode = 'tablet';\n        applyModeUI();\n        refreshLatestFrame();\n    }\n\n    /* =======================================================================================\n     * statistic_config (SHARED_SCOPE)\n     * ======================================================================================= */\n    function getCamStatId() {\n        return self._activeCam ? `CAM_${self._activeCam}` : null;\n    }\n\n    function readStatisticConfigShared() {\n        return new Promise((resolve, reject) => {\n            attributeService.getEntityAttributes(self._entityId, 'SHARED_SCOPE', ['statistic_config'])\n                .subscribe(attrs => {\n                    const a = (attrs || []).find(x => x.key === 'statistic_config');\n                    if (!a || a.value == null || a.value === '') { resolve(null); return; }\n                    let v = a.value;\n                    if (typeof v === 'string') { try { v = JSON.parse(v); } catch { /* keep raw */ } }\n                    resolve(v);\n                }, err => reject(err));\n        });\n    }\n\n    function writeStatisticConfigShared(cfg) {\n        return new Promise((resolve, reject) => {\n            attributeService.saveEntityAttributes(self._entityId, 'SHARED_SCOPE', [\n                { key: 'statistic_config', value: cfg }\n            ]).subscribe(() => resolve(), err => reject(err));\n        });\n    }\n\n    function normalizeRuleValue(v) {\n        if (!v) return 'none';\n        const s = String(v).toLowerCase();\n        if (s === 'in_out' || s === 'inout') return 'in_out';\n        return 'none';\n    }\n\n    function rulesFromCfg(cfg) {\n        const raw = cfg?.rules;\n        if (!Array.isArray(raw)) return [];\n        return raw.map(normalizeRuleValue);\n    }\n\n    function edgeFlatListFromPoints(pointsNorm) {\n        if (!pointsNorm || pointsNorm.length !== 4) return [];\n        const imgW = self._bgImg.naturalWidth || 1;\n        const imgH = self._bgImg.naturalHeight || 1;\n        const edges = [];\n        for (let i = 0; i < 4; i++) {\n            const a = pointsNorm[i];\n            const b = pointsNorm[(i + 1) % 4];\n            edges.push([\n                Math.round(a.x * imgW), Math.round(a.y * imgH),\n                Math.round(b.x * imgW), Math.round(b.y * imgH)\n            ]);\n        }\n        return edges;\n    }\n\n    function applyLineTypesFromConfig(cfg) {\n        self._lineTypes = [null, null, null, null];\n        if (!self._tabletPair || self._tabletPair.length !== 4) return;\n        const rules = rulesFromCfg(cfg);\n        if (rules.length === 4) {\n            for (let i = 0; i < 4; i++) {\n                const r = rules[i];\n                self._lineTypes[i] = (r === 'in_out') ? 'in_out' : null;\n            }\n        }\n    }\n\n    function applyLoadedFromStatisticConfig(cfg) {\n        if (cfg && typeof cfg === 'object' && !Array.isArray(cfg)) {\n            const flat = getLatestPointsFromCfg(cfg);\n            self._tabletPair = pixelFlatToNorm(flat);\n        } else {\n            self._tabletPair = [];\n        }\n        redraw();\n    }\n\n    function loadShared() {\n        return new Promise((resolve, reject) => {\n            readStatisticConfigShared().then(cfg => {\n                if (!cfg) {\n                    self._tabletPair = [];\n                    self._pending = null;\n                    redraw();\n                    resolve();\n                    return;\n                }\n\n                if (!self._bgReady) { self._pending = cfg; resolve(); return; }\n                applyLoadedFromStatisticConfig(cfg);\n                resolve();\n            }).catch(reject);\n        });\n    }\n\n    function saveShared() {\n        return new Promise((resolve, reject) => {\n            if (!self._bgReady) {\n                reject(new Error(t('err_frame_loading_try_again')));\n                return;\n            }\n\n            readStatisticConfigShared().then(cfg => {\n                if (!self._tabletPair || self._tabletPair.length < 3) {\n                    reject(new Error(t('err_need_4_points')));\n                    return;\n                }\n                if (polygonAreaNorm(self._tabletPair) < 0.00001) {\n                    reject(new Error(t('err_need_4_points')));\n                    return;\n                }\n\n                const newPoints = normToPixelFlat(self._tabletPair);\n\n                if (cfg == null || cfg === '') cfg = {};\n                if (typeof cfg === 'string') {\n                    try { cfg = JSON.parse(cfg); } catch { cfg = {}; }\n                }\n                if (Array.isArray(cfg) || typeof cfg !== 'object') {\n                    cfg = {};\n                }\n\n                cfg.points = newPoints;\n                delete cfg.rules;\n                writeStatisticConfigShared(cfg).then(resolve).catch(reject);\n            }).catch(reject);\n        });\n    }\n\n    /* ===== Frame HEX -> Image ===== */\n    function normalizeHexString(s) {\n        if (s == null) return '';\n        s = String(s).trim();\n        if (s.startsWith('0x') || s.startsWith('0X')) s = s.slice(2);\n        if (s.toLowerCase().startsWith('hex:')) s = s.slice(4);\n        s = s.replace(/[^0-9a-fA-F]/g, '');\n        if (s.length % 2 === 1) s = s.slice(0, -1);\n        return s;\n    }\n\n    function hexToBase64(hexNorm) {\n        if (!hexNorm) return '';\n        const bytes = new Uint8Array(hexNorm.length / 2);\n        for (let i = 0; i < hexNorm.length; i += 2) bytes[i / 2] = parseInt(hexNorm.substr(i, 2), 16);\n\n        const CHUNK = 0x8000;\n        let bin = '';\n        for (let j = 0; j < bytes.length; j += CHUNK) {\n            const sub = bytes.subarray(j, j + CHUNK);\n            bin += String.fromCharCode.apply(null, sub);\n        }\n        return btoa(bin);\n    }\n\n    // ✅ FIX: nhận hex đã normalize\n    function guessMimeFromHexNorm(hexNorm) {\n        if (!hexNorm || hexNorm.length < 16) return 'image/jpeg';\n        const h = String(hexNorm).toUpperCase();\n        if (h.startsWith('FFD8FF')) return 'image/jpeg';\n        if (h.startsWith('89504E470D0A1A0A')) return 'image/png';\n        if (h.startsWith('52494646')) return 'image/webp';\n        return 'image/jpeg';\n    }\n\n    function setFrameSrc(val) {\n        let src = val;\n\n        if (typeof val === 'string' && !val.startsWith('data:image')) {\n            const hexNorm = normalizeHexString(val);\n            if (hexNorm) {\n                const mime = guessMimeFromHexNorm(hexNorm);\n                const b64 = hexToBase64(hexNorm);\n                src = `data:${mime};base64,${b64}`;\n            } else {\n                // fallback legacy: treat as base64\n                src = 'data:image/jpeg;base64,' + val;\n            }\n        }\n\n        if (self._lastSrc === src) {\n            setLoading(false);\n            return;\n        }\n\n        self._lastSrc = src;\n        self._bgReady = false;\n\n        self._bgImg.onload = () => {\n            self._bgReady = true;\n            setLoading(false);\n\n            if (self._pending != null) {\n                applyLoadedFromStatisticConfig(self._pending);\n                self._pending = null;\n            }\n\n            redraw();\n        };\n\n        self._bgImg.onerror = () => {\n            self._bgReady = false;\n            setLoading(false);\n            toast('error', t('err_failed_load_image'));\n        };\n\n        self._bgImg.src = src;\n    }\n\n    function fetchFrame() {\n        if (self._mode === 'tablet' || self._mode === 'default') {\n            attributeService.getEntityAttributes(self._entityId, 'CLIENT_SCOPE', ['frame_base64'])\n                .subscribe(attrs => {\n                    const a = (attrs || []).find(x => x.key === 'frame_base64');\n                    if (a?.value) setFrameSrc(a.value);\n                    else setLoading(false);\n                }, () => setLoading(false));\n            return;\n        }\n\n        if (!self._activeCam) { setLoading(false); return; }\n        const key = `frame_cam${self._activeCam}`;\n        attributeService.getEntityAttributes(self._entityId, 'CLIENT_SCOPE', [key])\n            .subscribe(attrs => {\n                const a = (attrs || []).find(x => x.key === key);\n                if (a?.value) setFrameSrc(a.value);\n                else setLoading(false);\n            }, () => setLoading(false));\n    }\n\n    function setActiveCam(camId) {\n        if (!camId || self._activeCam === camId) return;\n        self._activeCam = camId;\n\n        self._tabletPair = [];\n        self._roisNorm = { Detect: [], Region1: [], Region2: [] };\n        self._pending = null;\n        self._lastSrc = null;\n\n        self._bgReady = false;\n        setLoading(true);\n        blankWhite();\n\n        loadShared().catch(() => { });\n\n        // ✅ REQUIRED: mỗi lần switch cam đều bắn camId vào get_frame_cam\n        refreshLatestFrame();\n    }\n\n    /* ===== Click add point ===== */\n    function onClickAddPoint(ev) {\n        const p = evToPointOnImageNorm(ev);\n        if (!p) return;\n\n        if (!self._tabletPair) self._tabletPair = [];\n        self._tabletPair.push(p);\n\n        self._justAddedPoint = true;\n        setTimeout(() => { self._justAddedPoint = false; }, 0);\n        redraw();\n    }\n\n    canvasEl.addEventListener('click', onClickAddPoint);\n    self._onClickAddPoint = onClickAddPoint;\n\n    /* ===== Toolbar actions ===== */\n    self.ctx.$scope.savePolygon = () => runWithFeedback(btnSaveEl, 'Save', () => saveShared());\n\n    self.ctx.$scope.undoPoint = () => runWithFeedback(btnUndoEl, 'Undo', () => {\n        if (self._tabletPair && self._tabletPair.length) self._tabletPair.pop();\n        updateCursor();\n        redraw();\n    }, { silent: true });\n\n    self.ctx.$scope.clearAll = () => runWithFeedback(btnClearEl, 'Clear', () => {\n        self._tabletPair = [];\n        updateCursor();\n        redraw();\n    });\n\n    self.ctx.$scope.reloadSaved = () => runWithFeedback(btnReloadEl, 'Reload', async () => {\n        await loadShared();\n        await refreshLatestFrame();\n    });\n\n    /* ===== Start ===== */\n    initI18n();\n    loadDeviceLabel();\n    loadShared().catch(() => { });\n};\n\nself.onDataUpdated = function () {\n    // Single device mode: no-op.\n};\n\nself.onDestroy = function () {\n    try {\n        if (self._ro) self._ro.disconnect();\n        if (self._onClickAddPoint) {\n            self.ctx.$container.find('canvas')[0].removeEventListener('click', self._onClickAddPoint);\n        }\n        if (typeof self._unsubTranslate === 'function') self._unsubTranslate();\n    } catch (e) { }\n};\n",
        "settingsForm": [],
        "dataKeySettingsForm": [],
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"ROI \",\"decimals\":null}"
      },
      "resources": [],
      "scada": false,
      "tags": null
    }
  ]
}